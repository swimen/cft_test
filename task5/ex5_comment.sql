РЕШЕНИЕ:
=================================================================
Создадим последовательность tst_seq

create sequence tst_seq START WITH 1  MAXVALUE 999999999999999999999999999  MINVALUE 1 CACHE 100;

Будем считать, что задача генерация первичных ключей в нашей базе решена централизованно
с помощью этой последовательности.

Для небольших справочников ключ можно формировать в триггере, но при выполнении массовых операций
срабатывание триггеров будет замедлять наше прилжение. Поэтому примем другую концепцию:
считаем, что работа с таблицами по добавлению, удалению и изменению записей реализована через
интерфейсные методы, и задачу формирования первичного ключа решают они. 
Соответственно доступ пользователей к таблицам для изменения данных разрешен только через методы.

Создадим таблицу  tst_opers для логирования запусков операции загрузки.
В таблицу tst_loading_log, добавим колонку со ссылкой на tst_opers
В случае ошибок это позволит полностью откатить результаты загрузки.
Откат обновления справочников единиц измерения и наименования товаров подобным образом не предусматриваем,
при необходимости их всегда можно почистить по не используемым значениям.

create table tst_opers (id number primary key, load_date date);
alter table tst_loading_log add oper_id number;
alter table tst_loading_log add constraint fk_tst_log_oper_id foreign key (oper_id) references tst_opers (id);


Запретим одновременный запуск нескольких процесс загрузки данных.
Для этого будем использовать функционал пакета dbms_lock.
Считаем, что запрет на работу с таблицами tst_docs, tst_doc_strings во время работы нашей процедуры
реализован на уровне приложения.


Учтем возможность ошибок связанных с использованием заглавных букв в названиях
единиц измерения и наименований товаров. А также наличие ведущих или конечных пробелов.
В справочник будем заность предварительно обработанные записи в верхнем регистре.
Для работы с приведенными значениями полей создадим индексы upper(trim(field_name))
в tst_units, tst_goods, tst_doc_strings

Считаем, что если на момент загрузки справочники единиц измерения и названий продуктов не пустые,
то их содержание нормализовано согласно обозначенных требований.
(можно также учесть наличие скрытых символов, таких как табуляция, перевод строки и т.д.)

create index tst_units_uname_idx on tst_units(UPPER(trim(name)));
create index tst_goods_uname_idx on tst_goods(UPPER(trim(name)));

create index TDS_unit_uname_idx on TST_DOC_STRINGS(UPPER(trim(unit_name)));
create index TDS_good_uname_idx on TST_DOC_STRINGS(UPPER(trim(good_name)));


Создадим таблицы tst_docs_err, tst_doc_strings_err для сохранения записей которые невозможно 
загрузить в силу тех или иных ошибок, это таблицы загрузки расширенные полем err_info и oper_id 

Создадим таблицу tst_loading_docs для хранения загруженных данных из tst_docs
Она позволит нам решить задачу контроля уникальности загруженных документов.
В условиях задачи явно это требование не озвучено, но без этого нельзя будет предотвратить повторную загрузку
одних и техже данных.
Считаем что наборы записей в tst_docs и tst_doc_strings это комплект данных связанный по doc_num
Отдельно друг от друга таблицы загружены быть не могут. По уже загруженному документу нельзя догружать строки
указывая загруженный ранее номер документа. (это можно было бы реализовать если ввести требования уникальности для
строк из tst_doc_strings)

create table tst_loading_docs (id number primary key, doc_num number not null, doc_date date);
create unique index tst_ldocs_num_idx on tst_loading_docs (doc_num);


Общая схема загрузки следующая

1. Сначала обновляем справочники единиц измерения и товаров, для единиц измерения делаем это одним запросом
   для товаров делаем итерации с ограничением по кол-ву записей. 

2. Загружаем сведения из tst_docs
   Порциями выбираем записи в pl/sql таблицу, и массово вставляем в tst_loading_docs с обработкой и сохранением ошибок в tst_docs_err
   Ограничения на tst_loading_docs автоматически обеспечат проверку корректности данных с точки зрения уникальности doc_num

3. Загружаем сведения из tst_doc_strings 
   В цыкле, порциями выбираем записи с уже привязанными id единицы измерения, id товара, doc_num, предварительно 
   определенным статусом загрузки и комментариаем о несущественных ошибках в pl/sql таблицу. 

   Массово вставляем записи из pl/sql таблицы в tst_doc_goods ошибки пишем в tst_doc_strings_err.
   используя returning  сразу получаем массив id созданных записей для вставки в  tst_loading_log.
   
   Обработанные записи из tst_doc_strings удаляем по rowid
   
4. Обрабатываем оставшиеся записи из tst_doc_strings, они попадают в  tst_doc_strings_err

9. Очищаем таблицы tst_doc_strings и tst_docs



Возможные ошибки:

- соответствие данных в tst_docs и tst_docs_string не контролируется на уровне базы
  поэтому при загрузке надо учесть варианты когда в tst_docs_string указан документ
  котороге нет в tst_docs.  

- Несоответствие длины полей tst_docs_strings.goood_name(4000) и tst_goods.name (500)
  учтем этот вариант в коде

- Возможен разный регистр в наименованиях продуктов и единиц измерения
  Лучше решать сразу созданием уникального индекса с приведением например к UPPER
  Так как по условиям задачи структуру менять нельзя, то учтем при загрузке

- Пустые значения в волях суммы и кол-ва

- Есть риск ошибок связанных с одновременным запуском нескольких процессов загрузки
  поэтому обеспечим запуск только одного процесса.

- Учтем возможность повторной загрузки одних и тех же данных.

- судя по всему предполагаются большие объемы загрузки данных,
  нужно ограничить обьем транзакций, для наглядности при тестировании  переменная max_row_count = 3
  для реальной работы можно установить значение 10000

- желательно ещё фиксировать возникающие ошибки в журнале который пишется в автономной транзакции.
